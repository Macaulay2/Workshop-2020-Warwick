-- -*- coding: utf-8-unix -*-

newPackage(
     "GraphicalModelsMLE",
     Version => "0.3",
     Date => "June 5, 2020",
     Authors => {
	  {Name=> "Carlos Amendola", 
	   Email=> "carlos.amendola@tum.de",
	   HomePage=>"http://www.carlos-amendola.com/"},
       
	  {Name => "Luis David Garcia Puente",
	   Email => "lgarcia@shsu.edu",
	   HomePage => "http://www.shsu.edu/~ldg005"},
       
          {Name=> "Roser Homs Pons", 
	   Email=> "roserhp@gmail.com",
	   HomePage=>"https://personal-homepages.mis.mpg.de/homspons/index.html"},
       
          {Name=> "Olga Kuznetsova", 
	   Email=> "kuznetsova.olga@gmail.com",
	   HomePage=>"https://okuznetsova.com"},
       
          {Name=> "Harshit J Motwani", 
	   Email=> "harshitmotwani2015@gmail.com"},
       
          {Name=> "Elina Robeva", 
	   Email=> "erobeva@gmail.com",
	   HomePage=>"http://math.berkeley.edu/~erobeva"},
       
          {Name=> "David Swinarski", 
	   Email=> "dswinarski@fordham.edu",
	   HomePage=>"http://faculty.fordham.edu/dswinarski"}
	  },
     Headline => "maximum likelihood estimates for graphical statistical models",
     DebuggingMode => true,
     PackageExports => {"GraphicalModels","Graphs","EigenSolver","NumericalAlgebraicGeometry","StatGraphs"}
     )
export {
    "checkPD",
    "checkPSD",
    "isPD",
    "isPSD",
    "chooseSolver",--optional argument in solverMLE
    "concentrationMatrix",-- optional argument in solverMLE
    "doSaturate",-- optional argument in scoreEquationsFromCovarianceMatrix and solverMLE
    "jacobianMatrixOfRationalFunction",
    "optionsES",--optional argument in solverMLE
    "optionsNAG4M2",--optional argument in solverMLE
    "sampleCovarianceMatrix",
    "sampleData",-- optional argument in scoreEquationsFromCovarianceMatrix and solverMLE
    "saturateOptions", -- optional argument in scoreEquationsFromCovarianceMatrix and solverMLE
    "MLdegree",
    "scoreEquations",
    "solverMLE"
     } 

--**************************--
--  INTERNAL ROUTINES       --
--**************************--



--*************************************--
--  Functions (local) used throughout  --
--*************************************--


--------------------------------------------
-- turn the entries of an integer matrix into rational numbers
--------------------------------------------

matZZtoQQ = (M) -> (
    E:=entries M;   
    return matrix apply(#E, i -> apply(#(E_i), j -> (1/1)*E_i_j))    
);

------------------------------------------------------
-- Substitues a list of points on a list of matrices
    -- input -  list of points from sols
    --          matrix whose entries are variables
    --          (expect it to be an inverse of a covariance matrix, Sin)
    -- output - list of matrices after substituting these values
------------------------------------------------------
genListMatrix = (L,A) ->
(
    T := {};
 
    for l in L do
    (
    	T = T|{coordinates(l)};	
    );
    M := {};
    for t in T do
    (
    	m := substitute(A,matrix{t});	
    	M = M|{m};
    );    
    return M
);

----------------------------------------------
-- Selects all argmax for log det K- trace(S*K),
-- where K is an element of the list L.
-- We assume that L is the intersection of the 
-- variety of the ideal generated by the Jacobian
-- of critical equations and the cone of PD matrices.

-- input - list L of candidate Sinv matrices (Sinv is Sigma^{-1}) and
-- sample covariance matrix V. Notation in line with scoreEquationsFromCovarianceMatrix
-- output -list of argmax
----------------------------------------------
maxMLE=(L,V)->(
    if #L==0 then  error("No critical points to evaluate");
    if #L==1 then  (E:=inverse L_0; maxPt:=log det L_0- trace (V*L_0))
    else 
    	(eval:=for Sinv in L list log det Sinv- trace (V*Sinv);
	evalReal:={};
	for pt in eval do (if isReal pt then evalReal=evalReal  | {pt});
	if #evalReal==0 then  error("No critical point evaluates to a real solution");
	maxPt=max evalReal;
	indexOptimal:=positions(eval, i ->i== maxPt);
	E={};
        for i in indexOptimal do E=E | {L_i};);
    return (maxPt, E) 
    );

-------------------------------------------
-- 
-------------------------------------------

-------------------------------------------
-- scoreEquationsInternal - function that returns
-- both the ideal and the corresponding SInv matrix.
-- The user-facing scoreEquations method returns only 
-- the ideal, whereas SInv is used in solverMLE
-------------------------------------------
scoreEquationsInternal={doSaturate => true, saturateOptions => options saturate, sampleData=>true}>>opts->(R,U)->(
    ----------------------------------------------------
    -- Extract information about the graph
    ---------------------------------------------------- 
    -- Lambda
    L := directedEdgesMatrix R;
    -- Psi
    P := bidirectedEdgesMatrix R;
    
    -- If the mixedGraph only has undirected part, call specific function for undirected.
    if L==0 and P==0 then 
    return scoreEquationsInternalUndir(R,U,opts);
       
    -- K 
    K := undirectedEdgesMatrix R;
    ----------------------------------------------------
    -- Create an auxiliary ring and its fraction field
    -- which do not have the s variables
    ----------------------------------------------------
    -- create a new ring, lpR, which does not have the s variables
    lpR:=coefficientRing(R)[gens R-set support covarianceMatrix R];
    -- create its fraction field
    FR := frac(lpR);
    
    -----------------------------------------------------
    -- Compute Sinv
    -----------------------------------------------------
    -- Kinv
    K=sub(K, FR);
    Kinv:=inverse K;
    P=sub(P,FR);
       
     --Omega
    if K==0 then W:=P else (if P==0 then W=Kinv else W = directSum(Kinv,P));
    
    -- move to FR, the fraction field of lpR
    L= sub(L,FR);
    
    -- Sigma
    d:=numcols L;
    if L==0 then S:=W else (
	IdL := inverse (id_(FR^d)-L);
    	S = (transpose IdL) * W * IdL
	);
    Sinv := inverse S; 
    
    -----------------------------------------------------  
    -- Compute score equations ideal
    ----------------------------------------------------
    -- Sample covariance matrix
    if opts.sampleData then V:= sampleCovarianceMatrix(U) else V=U;
    -- Jacobian of log-likelihood function
    C1 := trace(Sinv * V);
    C1derivative := jacobianMatrixOfRationalFunction(C1);
    LL :=jacobianMatrixOfRationalFunction (det Sinv)*matrix{{1/det(Sinv)}} - C1derivative;
    LL=flatten entries(LL);
    denoms := apply(#LL, i -> lift(denominator(LL_i), lpR));
    J:=ideal apply(#LL, i -> lift(numerator(LL_i),lpR));
    --Saturate
    if opts.doSaturate then (
        argSaturate:=opts.saturateOptions  >>newOpts-> args ->(args, newOpts);
    	for i from 0 to (#denoms-1) do (
	    if degree denoms_i =={0} then J=J else  
	    J=saturate(argSaturate(J,denoms_i))
	    ); 
	);
    return (J,Sinv);
);

----------------------------------------------------
--scoreEquationsInternalUndir for undirected graphs
----------------------------------------------------
scoreEquationsInternalUndir={doSaturate => true, saturateOptions => options saturate, sampleData=>true}>>opts->(R,U)->(    
    -- Sample covariance matrix
    if opts.sampleData then V := sampleCovarianceMatrix(U) else V=U;
    -- Concentration matrix K
    K:=undirectedEdgesMatrix R;
    -- move to a new ring, lpR, which does not have the s variables
    lpR:=coefficientRing(R)[gens R - set support covarianceMatrix R];
    K=sub(K,lpR);
    J:=ideal{jacobian ideal{determinant(K)}-determinant(K)*jacobian(ideal{trace(K*V)})};
    if opts.doSaturate then 
    (  	argSaturate:=opts.saturateOptions  >>newOpts-> args ->(args, newOpts);
    	J=saturate(argSaturate(J,ideal{determinant(K)}));
	);
    return (J,K);
 );

--**************************--
--  METHODS 	      	   	  --
--**************************--
sampleCovarianceMatrix = method(TypicalValue =>Matrix);
sampleCovarianceMatrix(Matrix) := (U) -> (
   n := numRows U;
   --Convert matrix into list of row matrices
   U = for i to n-1 list U^{i};
   --Convert from integers to rationals if needed
   U = apply(#U, i -> if ring(U_i)===ZZ then matZZtoQQ(U_i) else U_i);
   --Compute the mean vector
   Ubar := matrix{{(1/n)}} * sum(U);
   --Compute sample covariance matrix
   return ((1/n)*(sum apply(n, i -> (transpose (U#i-Ubar))*(U#i-Ubar))));        
);

sampleCovarianceMatrix(List) := (U) -> (
   return sampleCovarianceMatrix(matrix U);
);

jacobianMatrixOfRationalFunction = method(TypicalValue =>Matrix);
jacobianMatrixOfRationalFunction(RingElement) := (F) -> (
    if not class ring F===FractionField then error "Expected element in a field of fractions";
    f:=numerator(F);
    g:=denominator(F);
    R:=ring(f);
    answer:=diff(vars(R), f) * g - diff(vars(R), g)*f;
    answer=substitute(answer, ring(F));
    return transpose(matrix({{(1/g)^2}})*answer)
);

scoreEquations = method(TypicalValue =>Ideal, Options =>{sampleData => true, doSaturate => true, saturateOptions => options saturate});
scoreEquations(Ring,Matrix) := opts -> (R, U) -> ( 
    ----------------------------------------------------
    --Check input
    ----------------------------------------------------
    if not R.?graph then error "Expected a ring created with gaussianRing of a Graph, Bigraph, Digraph or MixedGraph";
    if not numRows U==#vertices R.graph  then error "Size of sample data does not match the graph.";  
    if not opts.sampleData then (if not U==transpose U then error "The sample covariance matrix must be symmetric.");
    ---------------------------------------------------
    -- Apply appropriate scoreEquations routine
    ---------------------------------------------------
    if R.graphType===Graph 
    then (J,Sinv):=scoreEquationsInternalUndir(R,U,opts)
    else (J,Sinv)=scoreEquationsInternal(R,U,opts);
    return J;
);

scoreEquations(Matrix,Ring) := opts ->(U,R) -> ( 
    return scoreEquations(R,U,opts);
    );

scoreEquations(Ring,List) := opts ->(R, U) -> ( 
    ----------------------------------------------------
    --Check input
    ----------------------------------------------------
    if not opts.sampleData then error "The sample covariance matrix must be a matrix.";
        
    ---------------------------------------------------
    -- Call scoreEquations routine with a matrix
    ---------------------------------------------------
    return scoreEquations(R,matrix U,opts);
);

scoreEquations(List,Ring) := opts ->(U,R) -> ( 
    return scoreEquations(R,U,opts);
    );


isPD = method()
isPD Matrix := Boolean => (M) -> (
    -- Check singularity
    if det M==0 then return false;
    -- Compute eigenvalues for each matrix
    E:=eigenvalues M; 
    --Check whether all of them are positive and real
    flag := 0;
    for e in E do 
    (	 
	if 0 >= e then flag = 1;
	if not isReal e then flag=1;
    );
    if flag==0 then true else false
);

isPSD = method()
isPSD Matrix := Boolean => (M) -> (
    flag := 0;
    -- Compute eigenvalues for each matrix
    E:=eigenvalues M; 
    --Check whether all of them are non-negative and real
    for e in E do 
    (	 
	if 0 > e then flag = 1;
	if not isReal e then flag=1;
    );
    if flag==0 then true else false
);


checkPD = method(TypicalValue =>List);
checkPD(List) := (L) -> (
   mat := {}; 
    for l in L do
    (   if isPD(l)==true then mat=mat|{l};
    );
    if mat == {} then print("none of the matrices are pd");
    return mat;
);

checkPSD = method(TypicalValue =>List);
checkPSD(List) := (L) -> (
   mat := {};
    for l in L do
    (   if isPSD(l)==true then mat=mat|{l};
    );
    if mat == {} then print("none of the matrices are psd");
    return mat;
);

MLdegree = method(TypicalValue =>ZZ);
MLdegree(Ring):= (R) -> (
   if not R.?graph then error "Expected gaussianRing created from a graph, digraph, bigraph or mixedGraph";
   n:=# vertices R.graph;
   J:=scoreEquations(R,random(QQ^n,QQ^n));
   return degree J;
);


solverMLE = method(TypicalValue =>Sequence, Options =>{sampleData=>true, concentrationMatrix=> true, doSaturate => true, saturateOptions => options saturate, chooseSolver=>"EigenSolver", optionsES => options zeroDimSolve, optionsNAG4M2=> options solveSystem});
solverMLE(MixedGraph,Matrix) := opts -> (G, U) -> (
    -- check input
    if not numRows U==#vertices G then error "Size of sample data does not match the graph."; 
    -- generate the Gaussian ring of the MixedGraph
    R:= gaussianRing(G);
    -- sample covariance matrix
    if opts.sampleData then V := sampleCovarianceMatrix(U) 
    else (V=U; 
    if not V==transpose V then error "The sample covariance matrix must be symmetric.");
    if det V==0 then print "Warning: The sample covariance matrix is singular";
    -- generate the ideal of the score equations
    if opts.doSaturate then (
	 argSaturate:=opts.saturateOptions  >>newOpts-> args ->(args, saturateOptions=>newOpts,sampleData=>false);
         (J,SInv):=scoreEquationsInternal(argSaturate(R,V));)
    else (J,SInv)= scoreEquationsInternal(R,V,doSaturate=>false, sampleData=>false);
    -- check that the system has finitely many solutions
    if dim J =!= 0 then (
	print ("the ideal is not zero-dimensional");
	return J;
	) else (
    ML:=degree J;
    -- solve system 
    if opts.chooseSolver=="EigenSolver" then(
	argES:=opts.optionsES  >>newOpts-> args ->(args, newOpts);
        sols:=zeroDimSolve(argES(J));
	) else (
	if opts.chooseSolver=="NAG4M2" then (
	   sys:= (for i to (numcols gens J)-1 list (gens J)_(0,i)); 
	   argNAG4M2:=opts.optionsNAG4M2 >>newOpts-> args ->(args, newOpts);
           sols=solveSystem(argNAG4M2(sys));
	    )
	else error "Accepted solver options are EigenSolver 
	(which uses function zeroDimSolve) or NAG4M2 (which uses solveSystem). Options should 
	be given as strings.";  
	);
   
    --evaluate matrices on solutions
    M:=genListMatrix(sols,SInv);
    --consider only PD matrices    
    L:=checkPD M;
    --find the optimal points
    (maxPt, E):=maxMLE(L,V);
    if not opts.concentrationMatrix then (
	if class E=== List then 	E=(for e in E list e=inverse e) else  E=inverse E
	);
    return  (maxPt,E,ML));    
);

-- Allow list instead of matrix
solverMLE(MixedGraph,List):=  opts ->(G,U) -> (
    -- check input
    if not opts.sampleData then error "The sample covariance matrix must be a matrix.";
    -- call solverMLE for a matrix
    return  solverMLE(G,matrix U,opts);    
);


-- Permutations of input

solverMLE(Graph,List) := opts -> (G, U) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );

solverMLE(Digraph,List) := opts -> (G, U) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(Bigraph,List) := opts -> (G, U) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(Graph,Digraph,List) := opts -> (G,D,U) -> (
    return solverMLE(mixedGraph (G,D),U, opts);
    );
solverMLE(Digraph,Graph,List) := opts -> (D,G,U) -> (
    return solverMLE(mixedGraph (D,G),U, opts);
    );
solverMLE(Digraph,Bigraph,List) := opts -> (D,B,U) -> (
    return solverMLE(mixedGraph (D,B),U, opts);
    );
solverMLE(Bigraph,Digraph,List) := opts -> (B,D,U) -> (
    return solverMLE(mixedGraph (B,D),U, opts);
    );
solverMLE(Graph, Bigraph,List) := opts -> (G,B,U) -> (
    return solverMLE(mixedGraph (G,B),U, opts);
    );
solverMLE(Bigraph,Graph,List) := opts -> (B,G,U) -> (
    return solverMLE(mixedGraph (B,G),U, opts);
    );
solverMLE(Graph, Digraph, Bigraph, List) := opts -> (G,D,B,U) -> (
    return solverMLE(mixedGraph (G,D,B),U, opts);
    );
solverMLE(Digraph, Bigraph, Graph, List) := opts -> (D,B,G,U) -> (
    return solverMLE(mixedGraph (D,B,G),U, opts);
    );
solverMLE(Bigraph, Graph, Digraph, List) := opts -> (B,G,D,U) -> (
    return solverMLE(mixedGraph (B,G,D),U, opts);
    );
solverMLE(Graph,Bigraph, Digraph, List) := opts -> (G,B,D,U) -> (
    return solverMLE(mixedGraph (G,B,D),U, opts);
    );
solverMLE(Bigraph, Digraph,Graph, List) := opts -> (B,D,G,U) -> (
    return solverMLE(mixedGraph (B,D,G),U, opts);
    );
solverMLE(Digraph, Graph, Bigraph, List) := opts -> (D,G,B,U) -> (
    return solverMLE(mixedGraph (D,G,B),U, opts);
    );

solverMLE(List,MixedGraph) := opts -> (U,G) -> (
    return solverMLE(G,U, opts);
    );

solverMLE(List,Graph) := opts -> (U,G) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );

solverMLE(List,Digraph) := opts -> (U,G) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(List,Bigraph) := opts -> (U,G) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(List,Graph,Digraph) := opts -> (U,G,D) -> (
    return solverMLE(mixedGraph (G,D),U, opts);
    );
solverMLE(List,Digraph,Graph) := opts -> (U,D,G) -> (
    return solverMLE(mixedGraph (D,G),U, opts);
    );
solverMLE(List,Digraph,Bigraph) := opts -> (U,D,B) -> (
    return solverMLE(mixedGraph (D,B),U, opts);
    );
solverMLE(List,Bigraph,Digraph) := opts -> (U,B,D) -> (
    return solverMLE(mixedGraph (B,D),U, opts);
    );
solverMLE(List,Graph, Bigraph) := opts -> (U,G,B) -> (
    return solverMLE(mixedGraph (G,B),U, opts);
    );
solverMLE(List,Bigraph,Graph) := opts -> (U,B,G) -> (
    return solverMLE(mixedGraph (B,G),U, opts);
    );
solverMLE(List,Graph, Digraph, Bigraph) := opts -> (U,G,D,B) -> (
    return solverMLE(mixedGraph (G,D,B),U, opts);
    );
solverMLE(List,Digraph, Bigraph, Graph) := opts -> (U,D,B,G) -> (
    return solverMLE(mixedGraph (D,B,G),U, opts);
    );
solverMLE(List,Bigraph, Graph, Digraph) := opts -> (U,B,G,D) -> (
    return solverMLE(mixedGraph (B,G,D),U, opts);
    );
solverMLE(List,Graph,Bigraph, Digraph) := opts -> (U,G,B,D) -> (
    return solverMLE(mixedGraph (G,B,D),U, opts);
    );
solverMLE(List,Bigraph, Digraph,Graph) := opts -> (U,B,D,G) -> (
    return solverMLE(mixedGraph (B,D,G),U, opts);
    );
solverMLE(List,Digraph, Graph, Bigraph) := opts -> (U,D,G,B) -> (
    return solverMLE(mixedGraph (D,G,B),U, opts);
    );

solverMLE(Graph,Matrix) := opts -> (G, U) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );

solverMLE(Digraph,Matrix) := opts -> (G, U) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(Bigraph,Matrix) := opts -> (G, U) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(Graph,Digraph,Matrix) := opts -> (G,D,U) -> (
    return solverMLE(mixedGraph (G,D),U, opts);
    );
solverMLE(Digraph,Graph,Matrix) := opts -> (D,G,U) -> (
    return solverMLE(mixedGraph (D,G),U, opts);
    );
solverMLE(Digraph,Bigraph,Matrix) := opts -> (D,B,U) -> (
    return solverMLE(mixedGraph (D,B),U, opts);
    );
solverMLE(Bigraph,Digraph,Matrix) := opts -> (B,D,U) -> (
    return solverMLE(mixedGraph (B,D),U, opts);
    );
solverMLE(Graph, Bigraph,Matrix) := opts -> (G,B,U) -> (
    return solverMLE(mixedGraph (G,B),U, opts);
    );
solverMLE(Bigraph,Graph,Matrix) := opts -> (B,G,U) -> (
    return solverMLE(mixedGraph (B,G),U, opts);
    );
solverMLE(Graph, Digraph, Bigraph, Matrix) := opts -> (G,D,B,U) -> (
    return solverMLE(mixedGraph (G,D,B),U, opts);
    );
solverMLE(Digraph, Bigraph, Graph, Matrix) := opts -> (D,B,G,U) -> (
    return solverMLE(mixedGraph (D,B,G),U, opts);
    );
solverMLE(Bigraph, Graph, Digraph, Matrix) := opts -> (B,G,D,U) -> (
    return solverMLE(mixedGraph (B,G,D),U, opts);
    );
solverMLE(Graph,Bigraph, Digraph, Matrix) := opts -> (G,B,D,U) -> (
    return solverMLE(mixedGraph (G,B,D),U, opts);
    );
solverMLE(Bigraph, Digraph,Graph, Matrix) := opts -> (B,D,G,U) -> (
    return solverMLE(mixedGraph (B,D,G),U, opts);
    );
solverMLE(Digraph, Graph, Bigraph, Matrix) := opts -> (D,G,B,U) -> (
    return solverMLE(mixedGraph (D,G,B),U, opts);
    );

solverMLE(Matrix,MixedGraph) := opts -> (U,G) -> (
    return solverMLE(G,U, opts);
    );

solverMLE(Matrix,Graph) := opts -> (U,G) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );

solverMLE(Matrix,Digraph) := opts -> (U,G) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(Matrix,Bigraph) := opts -> (U,G) -> (
    return solverMLE(mixedGraph (G),U, opts);
    );
solverMLE(Matrix,Graph,Digraph) := opts -> (U,G,D) -> (
    return solverMLE(mixedGraph (G,D),U, opts);
    );
solverMLE(Matrix,Digraph,Graph) := opts -> (U,D,G) -> (
    return solverMLE(mixedGraph (D,G),U, opts);
    );
solverMLE(Matrix,Digraph,Bigraph) := opts -> (U,D,B) -> (
    return solverMLE(mixedGraph (D,B),U, opts);
    );
solverMLE(Matrix,Bigraph,Digraph) := opts -> (U,B,D) -> (
    return solverMLE(mixedGraph (B,D),U, opts);
    );
solverMLE(Matrix,Graph, Bigraph) := opts -> (U,G,B) -> (
    return solverMLE(mixedGraph (G,B),U, opts);
    );
solverMLE(Matrix,Bigraph,Graph) := opts -> (U,B,G) -> (
    return solverMLE(mixedGraph (B,G),U, opts);
    );
solverMLE(Matrix,Graph, Digraph, Bigraph) := opts -> (U,G,D,B) -> (
    return solverMLE(mixedGraph (G,D,B),U, opts);
    );
solverMLE(Matrix,Digraph, Bigraph, Graph) := opts -> (U,D,B,G) -> (
    return solverMLE(mixedGraph (D,B,G),U, opts);
    );
solverMLE(Matrix,Bigraph, Graph, Digraph) := opts -> (U,B,G,D) -> (
    return solverMLE(mixedGraph (B,G,D),U, opts);
    );
solverMLE(Matrix,Graph,Bigraph, Digraph) := opts -> (U,G,B,D) -> (
    return solverMLE(mixedGraph (G,B,D),U, opts);
    );
solverMLE(Matrix,Bigraph, Digraph,Graph) := opts -> (U,B,D,G) -> (
    return solverMLE(mixedGraph (B,D,G),U, opts);
    );
solverMLE(Matrix,Digraph, Graph, Bigraph) := opts -> (U,D,G,B) -> (
    return solverMLE(mixedGraph (D,G,B),U, opts);
    );

--******************************************--
-- DOCUMENTATION     	       	    	    -- 
--******************************************--

beginDocumentation()

doc ///
    Key
        GraphicalModelsMLE
    Headline
        a package for MLE estimates of parameters for statistical graphical models 
    Description        
        Text
            The following text should include a general description and references...so far only some copy-paste   


            This function computes the score equations that arise from the 
	    maximization of the log-likelihood function of the covariance matrix 
	    (or its inverse: the concentration matrix) of a Gaussian graphical
	    statistical model and returns the ideal generated by such equations.
	    

	    {\tt scoreEquations} computes the score equations that arise from the 
	    maximization of the log-likelihood function of a graphical Gaussian
	    statistical model given in Proposition 7.1.10 (Sullivant, 2018):
	    
	    $\ell(\Sigma)=-n/2 log det \Sigma - n/2 tr (S\Sigma^{-1})$,
	    
	    as a function of $\Sigma^{-1}$.
	    
	    References
	    
	   
	    Sullivant, S., 2018. Algebraic statistics (Vol. 194). American Mathematical Soc.

	    
	    In the example below, we create the score equations (defining the critical points of the log likelihood function written in terms of the covariance matrix) associated to the four data vectors $(1,2,1,-1)$, $(2,1,3,0)$, $(-1,0,1,1)$, $(-5,3,4,-6)$ for a graphical model with four vertices, five directed edges, and one bidirected edge.


	    
        Example	   
	    G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph {{3,4}})
	    R = gaussianRing(G)
	    U = {matrix{{1,2,1,-1}}, matrix{{2,1,3,0}}, matrix{{-1, 0, 1, 1}}, matrix{{-5, 3, 4, -6}}}
            scoreEquations(R,U)
	    
	    
       Example
           G= mixedGraph(graph{{a,b},{b,c}},digraph {{a,d},{c,e},{f,g}},bigraph {{d,e}})
           solverMLE (G, random(QQ^7,QQ^7))
    		   	    
       Example
           M = {matrix{{1, 2, 0}}, matrix{{-1, 0, 5/1}}, matrix{{3, 5, 2/1}}, matrix{{-1, -4, 1/1}}};
	   sampleCovarianceMatrix(M)
	   U= matrix{{1,2,1,-1},{2,1,3,0},{-1, 0, 1, 1},{-5, 3, 4, -6}};
	   sampleCovarianceMatrix(U)
	   
       Example
	   R=QQ[x,y];
	   FR=frac R;
	   F=1/(x^2+y^2);
           jacobianMatrixOfRationalFunction(F)
	   R=QQ[t_1,t_2,t_3];
	   FR=frac R;
	   jacobianMatrixOfRationalFunction( (t_1^2*t_2)/(t_1+t_2^2+t_3^3) )
	   
      Example
	    L={matrix{{1,0},{0,1}},matrix{{-2,0},{0,1}},matrix{{sqrt(-1),0},{0,sqrt (-1)}}}				
    	    checkPD(L)
       
      Example
	    L={matrix{{1,0},{0,1}},matrix{{-2,0},{0,1}},matrix{{sqrt(-1),0},{0,sqrt (-1)}},matrix{{0,0},{0,0}}}				
    	    checkPSD(L)	   	
    Caveat
        GraphicalModelsMLE requires  @TO Graphs@,  @TO StatGraphs@ and  @TO GraphicalModels@.
///

--------------------------------
-- Documentation
--------------------------------

doc /// 
    Key
        sampleCovarianceMatrix
        (sampleCovarianceMatrix, List) 
	(sampleCovarianceMatrix, Matrix) 
    Headline
        sample covariance matrix of observation vectors
    Usage
        sampleCovarianceMatrix U
    Inputs
	U:Matrix
	   or @TO List@ of sample data
    Outputs
         :Matrix
           sample covariance matrix of the sample data
    Description 
        Text
	    The sample covariance matrix is $S = \frac{1}{n} \sum_{i=1}^{n} (X^{(i)}-\bar{X}) (X^{(i)}-\bar{X})^T$.  
	    Note that for normally distributed random variables $S$ is the maximum likelihood estimator (MLE) of the 
	    covariance matrix. This is different from the unbiased estimator, which uses a denominator of $n-1$ instead of $n$.
	    
	    Sample data is inputed as a matrix or a list.
	    The rows of the matrix or the elements of the list are observation vectors.  
	Example
          L= {{1,2,1,-1},{2,1,3,0},{-1, 0, 1, 1},{-5, 3, 4, -6}};
	  sampleCovarianceMatrix(L)
	  U= matrix{{1,2,1,-1},{2,1,3,0},{-1, 0, 1, 1},{-5, 3, 4, -6}};
	  sampleCovarianceMatrix(U)
	  	    
     ///

doc /// 
    Key
        jacobianMatrixOfRationalFunction
        (jacobianMatrixOfRationalFunction,RingElement) 
    Headline
        Jacobian matrix of a rational function
    Usage
        jacobianMatrixOfRationalFunction(F)
    Inputs
        F:RingElement
           in @TO frac@
    Outputs
         :Matrix
	   the Jacobian matrix of a rational function
    Description 
        Text
	    This function computes the Jacobian matrix of a rational function. 
	    The input is an element in a fraction field.
        Example
	    R=QQ[x,y];
	    FR=frac R;
	    F=1/(x^2+y^2);
            jacobianMatrixOfRationalFunction(F)
        Example  	    
	    R=QQ[t_1,t_2,t_3];
	    FR=frac R;
	    jacobianMatrixOfRationalFunction( (t_1^2*t_2)/(t_1+t_2^2+t_3^3) )
   ///

-------------------------------------------------------
-- Documentation scoreEquations -----------------------
-------------------------------------------------------

doc /// 
    Key
        scoreEquations
        (scoreEquations, Ring, List) 
	(scoreEquations, Ring, Matrix)
	(scoreEquations, List, Ring)
	(scoreEquations, Matrix, Ring) 
    Headline
        score equations of the log-likelihood function of a Gaussian graphical model
    Usage
        scoreEquations(R,U)
    Inputs
        R:Ring 
	   defined as a @TO gaussianRing@ of @TO Graph@, or @TO Digraph@, or @TO Bigraph@, or @TO MixedGraph@ 

	U:Matrix
	   or @TO List@ of sample data. 
	   Alternatively, the input can be the sample covariance @TO Matrix@ by setting the optional input @TO sampleData@ to false
    Outputs
         :Ideal
	   generated by the score equations of the log-likelihood function of the Gaussian model
    Description 
        Text
	    This function computes the score equations that arise from taking 
	    partial derivatives of the log-likelihood function of the concentration matrix 
	    (the inverse of the covariance matrix) of a Gaussian graphical
	    statistical model and returns the ideal generated by such equations.
	    
	    The input of this function is a @TO gaussianRing@ and statistical data.
	    The latter can be given as a matrix or a list of observations. The rows of the matrix or the elements of the list are observation vectors given as lists.  
            It is possible to input the sample covariance matrix directly by using the optional input @TO sampleData@.
            	    
	Example
	    G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph{{3,4}})
	    R = gaussianRing(G)
	    U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,
            1, 8/3}}
	    JU=scoreEquations(R,U)
	    V = sampleCovarianceMatrix U
	    JV=scoreEquations(R,V,sampleData=>false)
            
	Text
	    @TO saturateOptions@ allows to use all functionalities of @TO saturate@.
	    @TO doSaturate@ removes the saturation procedure. Note that the latter will not
	    provide the score equations of the model. 
        
	Example
	    G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph{{3,4}})
	    R = gaussianRing(G)
            U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,
            1, 8/3}}
            J=scoreEquations(R,U,saturateOptions => {Strategy => Eliminate})
            JnoSat=scoreEquations(R,U,doSaturate=>false)   
	    
	Text
	   The ML-degree of the model is the degree of the score equations ideal. The ML-degree 
	   of the running example is 1:
	
	Example
	    G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph{{3,4}})
	    R = gaussianRing(G)
	    U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,1, 8/3}}
	    JU=scoreEquations(R,U)
	    dim JU, degree JU
    ///
    
doc ///
  Key
    doSaturate
  Headline
    optional input to remove saturation 
  SeeAlso
     scoreEquations
     solverMLE
   ///

doc ///
  Key
    [scoreEquations, doSaturate]
    [solverMLE, doSaturate]
  Headline
     optional input to remove saturation 
  Usage
    scoreEquations(R,U,doSaturate=>true)
    solverMLE(G,U,doSaturate=>true)  
  Inputs 
    true: Boolean
    
  Description
    
    Text
     @TO doSaturate@ is set to true by default. 
     Note that avoiding saturation is only intended for big computations 
     when saturation cannot be computed or the computational time is very high. 
     It will not provide the score equations but only the ideal before the saturation procedure, 
     which is not 0-dimensional.
    
     For graphs with only undirected edges, score equations are the saturation of the
     outputed ideal by the determinant of the concentration matrix. In the general case,
     score equations consist of the saturation of the outputed ideal by the denominators
     of the Jacobian matrix.
     
     For example, in the following case the degree of the ideal prior to saturation already gives the right ML-degree:
    Example
     G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph {{3,4}});
     R=gaussianRing(G);
     U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,1, 8/3}};
     JnoSat=scoreEquations(R,U,doSaturate=>false);
     dim JnoSat  
     degree JnoSat     
     J=scoreEquations(R,U)
     degree JnoSat==degree J
     
    Text
     When we apply the no saturation option to solverMLE, the function returns the output
     of @TO scoreEquations@ with @TO doSaturate@ set to false. 
    Example
     G=graph{{1,2},{2,3},{3,4},{1,4}}
     U=random(ZZ^4,ZZ^4)
     solverMLE(G,U,doSaturate=>false)     
  SeeAlso
     scoreEquations
     solverMLE 	
///

doc ///
  Key
    saturateOptions
  Headline
    optional input to use options from @TO saturate@
  SeeAlso
     scoreEquations
     solverMLE
     doSaturate
     saturate
   ///
doc ///
  Key
    [scoreEquations, saturateOptions]
    [solverMLE, saturateOptions]
  Headline
    optional input to use options from @TO saturate@
  Usage
    scoreEquations(R,U,saturateOptions=>options saturate)
    solverMLE(G,U,saturateOptions=>options saturate)  
  Inputs 
    L: List
       list of options to set up saturation. Accepts any option from the function
       @TO saturate@
    
  Description
    Text
     Default @TO saturateOptions@ in @TO scoreEquations@ and @TO solverMLE@ are the 
     default options in @TO saturate@. All optional input in @TO saturate@ is allowed.
     
    Example
     G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph {{3,4}})
     R=gaussianRing(G)
     U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,1, 8/3}};
     J=scoreEquations(R,U,saturateOptions => {DegreeLimit=>1, MinimalGenerators => false})
    
    Example
     G=graph{{1,2},{2,3},{3,4},{1,4}}
     U=random(ZZ^4,ZZ^4)
     solverMLE(G,U,saturateOptions => {DegreeLimit=>1, MinimalGenerators => false})     

  SeeAlso
     scoreEquations   
     doSaturate
     saturate
     solverMLE	
///

doc ///
  Key
    chooseSolver 
  Headline
    optional input to choose numerical solver
  SeeAlso
    solverMLE
    EigenSolver
    NumericalAlgebraicGeometry
    zeroDimSolve
    solveSystem 
   ///
doc ///
  Key
    [solverMLE, chooseSolver]
  Headline
    optional input to choose numerical solver
  Usage
    solverMLE(G,U,chooseSolver=>"EigenSolver")  
  Inputs 
    P: String
       name of the corresponding package
    
  Description
    Text
      This option allows to choose which numerical solver to use to estimate the critical
      points. There are two options: "EigenSolver" or "NAG4M2".
      
      The default and strongly recommended option is "EigenSolver", in which case
      the function @TO zeroDimSolve@. If "NAG4M2" is chosen, then @TO solveSystem@ is used.	  
    Example
     G=mixedGraph(graph{{a,b},{b,c}})
     solverMLE (G, matrix{{1,0,0},{0,1,0},{0,0,1}},chooseSolver=>"EigenSolver")
     solverMLE (G, matrix{{1,0,0},{0,1,0},{0,0,1}},chooseSolver=>"NAG4M2")  
  SeeAlso
     solverMLE
     EigenSolver
     NumericalAlgebraicGeometry
     zeroDimSolve
     solveSystem 	
///

doc ///
  Key
    optionsES
  Headline
    optional input to set the parameters of zeroDimSolve in EigenSolver
  SeeAlso
    solverMLE
    EigenSolver
    zeroDimSolve
   ///
doc ///
  Key
    [solverMLE, optionsES]
  Headline
    optional input to set the parameters of zeroDimSolve in EigenSolver
  Usage
    solverMLE(G,U,chooseSolver=>"EigenSolver",optionsES=>options zeroDimSolve)
  Inputs 
    L: List
       list of optional inputs to @TO zeroDimSolve@
    
  Description
    Example
     G=mixedGraph(graph{{a,b},{b,c}})
     solverMLE(G,matrix{{1,0,0},{0,1,0},{0,0,1}},chooseSolver=>"EigenSolver",optionsES=>{Multiplier =>1, Strategy=>"Stickelberger"})  
     
  SeeAlso
     solverMLE
     EigenSolver
     zeroDimSolve	
///

doc ///
  Key
   optionsNAG4M2
  Headline
   optional parameter to set the parameters of solveSystem in NumericalAlgebraicGeometry
  SeeAlso
   solverMLE
   NumericalAlgebraicGeometry
   solveSystem
   ///
   
doc ///
  Key
    [solverMLE, optionsNAG4M2]
  Headline
    optional parameter to set the parameters of solveSystem in NumericalAlgebraicGeometry
  Usage
    solverMLE(G,U,chooseSolver=>"NAG4M2",optionsES=>options solveSystem)
  Inputs 
    L: List
       list of optional inputs to @TO solveSystem@
    
  Description
    Example
     G=mixedGraph(graph{{a,b},{b,c}})
     solverMLE(G,matrix{{1,0,0},{0,1,0},{0,0,1}},chooseSolver=>"NAG4M2",optionsNAG4M2=>{tStep =>.01,numberSuccessesBeforeIncrease => 5})  
     
  SeeAlso
     solverMLE
     NumericalAlgebraicGeometry
     solveSystem	
///

doc ///
  Key
    sampleData
  Headline
    optional input to allow to input the sample covariance matrix instead of sample data
  SeeAlso
     scoreEquations
     solverMLE
   ///
doc ///
  Key
    [scoreEquations, sampleData]
    [solverMLE, sampleData]
  Headline
    optional input to allow to input the sample covariance matrix instead of sample data
  Usage
    scoreEquations(R,U,sampleData=>true)
    solverMLE(G,U,sampleData=>true)  
  Inputs 
    true: Boolean
    
  Description
    Example
     G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph {{3,4}});
     R=gaussianRing(G);
     U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,1, 8/3}}
     J=scoreEquations(R,U,sampleData=>true)
     V=sampleCovarianceMatrix(U)
     I=scoreEquations(R,V,sampleData=>false)
     
    Example
     G=graph{{1,2},{2,3},{3,4},{1,4}}
     U=random(ZZ^4,ZZ^4)
     solverMLE(G,U,sampleData=>true)
     V=sampleCovarianceMatrix(U)
     solverMLE(G,V,sampleData=>false)     
  SeeAlso
     scoreEquations
     solverMLE 	
///

doc ///
  Key
    concentrationMatrix
  Headline
    optional input to output covariance matrices instead of concentration matrices
  SeeAlso
    solverMLE
   ///
doc ///
  Key
    [solverMLE, concentrationMatrix]
  Headline
    optional input to output covariance matrices instead of concentration matrices
  Usage
    solverMLE(G,U,concentrationMatrix=>true)  
  Inputs 
    true: Boolean
    
  Description
    Text
     By default, solverMLE outputs the MLE for the concentration matrix.
    Example
      G= mixedGraph(graph{{a,b},{b,c}},digraph {{a,d},{c,e},{f,g}},bigraph {{d,e}})
      solverMLE (G, random(QQ^7,QQ^7), concentrationMatrix=>true)
      solverMLE (G, random(QQ^7,QQ^7), concentrationMatrix=>false)    
  SeeAlso
     solverMLE 	
///


doc   ///
    Key
    	checkPD
	(checkPD,List)
    Headline
    	checks which matrices from a list are positive definite
    Usage
    	checkPD(L)
    Inputs
    	L: List  
	    list of matrices
    Outputs
    	 : List
	   list of positive definite matrices
    Description
    	Text
	   This function takes a list of matrices and returns another list with
	   only positive definite matrices
      	Example
	    L={matrix{{1,0},{0,1}},matrix{{-2,0},{0,1}},matrix{{sqrt(-1),0},{0,sqrt (-1)}}}				
    	    checkPD(L)
     	 ///

doc   ///
    Key
    	checkPSD
	(checkPSD,List)
    Headline
    	checks which matrices from a list are positive semidefinite
    Usage
    	checkPSD(L)
    Inputs
    	L: List  
	    list of matrices
    Outputs
    	 : List
	   list of positive semidefinite matrices
    Description
    	Text
	   This function takes a list of matrices and returns another list with
	   only positive semidefinite matrices
      	Example
	    L={matrix{{1,0},{0,1}},matrix{{-2,0},{0,1}},matrix{{sqrt(-1),0},{0,sqrt (-1)}},matrix{{0,0},{0,0}}}				
    	    checkPSD(L)
     	 ///

doc   ///
    Key
    	MLdegree
	(MLdegree,Ring)
    Headline
    	ML-degree of a graphical model
    Usage
    	MLdegree(R)
    Inputs
    	R: Ring  
	    defined as a @TO gaussianRing@ of @TO Graph@, or @TO Digraph@, or @TO Bigraph@, or @TO MixedGraph@ 
    Outputs
    	 : ZZ
	   ML-degree of the model
    Description
    	Text
	   This function computes the ML-degree of a graphical model. It takes as input 
	   a @TO gaussianRing@ of a @TO Graph@, or a @TO Digraph@, or a @TO Bigraph@, or a  @TO MixedGraph@.
	   It computes the degree of the score equation ideal given by @TO scoreEquations@ 
	   with a random sample data matrix. 
      	   
	   We compute the ML-degree of the 4-cycle:
	Example
	    G=graph{{1,2},{2,3},{3,4},{4,1}}
            MLdegree(gaussianRing G)

     	 ///


doc ///
    Key
        solverMLE
	(solverMLE,MixedGraph,List)
	(solverMLE, MixedGraph, Matrix)
	(solverMLE, Graph, List)
	(solverMLE, Digraph, List)
	(solverMLE, Bigraph, List)
	(solverMLE, Graph, Digraph,List)
	(solverMLE, Digraph, Graph,List)
	(solverMLE, Digraph, Bigraph, List)
	(solverMLE, Bigraph, Digraph, List)
	(solverMLE, Graph, Bigraph, List)
	(solverMLE, Bigraph, Graph, List)
	(solverMLE, Graph, Digraph, Bigraph, List)
	(solverMLE, Digraph, Bigraph, Graph, List)
	(solverMLE, Bigraph, Graph, Digraph, List)
	(solverMLE, Graph, Bigraph, Digraph, List)
	(solverMLE, Bigraph, Digraph, Graph, List)
	(solverMLE, Digraph, Graph, Bigraph, List)
	(solverMLE, List, MixedGraph)
	(solverMLE, List, Graph)
	(solverMLE, List, Digraph)
	(solverMLE, List, Bigraph)
	(solverMLE, List, Graph, Digraph)
	(solverMLE, List, Digraph,Graph)
	(solverMLE, List, Digraph,Bigraph)
	(solverMLE, List, Bigraph,Digraph)
	(solverMLE, List, Graph, Bigraph)
	(solverMLE, List, Bigraph, Graph)
	(solverMLE, List, Graph, Digraph, Bigraph)
	(solverMLE, List, Digraph, Bigraph, Graph)
	(solverMLE, List, Bigraph, Graph, Digraph)
	(solverMLE, List, Graph, Bigraph, Digraph)
	(solverMLE, List, Bigraph, Digraph, Graph)
	(solverMLE, List, Digraph, Graph, Bigraph)
	(solverMLE, Graph, Matrix)
	(solverMLE, Digraph, Matrix)
	(solverMLE, Bigraph, Matrix)
	(solverMLE, Graph, Digraph,Matrix)
	(solverMLE, Digraph, Graph,Matrix)
	(solverMLE, Digraph, Bigraph, Matrix)
	(solverMLE, Bigraph, Digraph, Matrix)
	(solverMLE, Graph, Bigraph, Matrix)
	(solverMLE, Bigraph, Graph, Matrix)
	(solverMLE, Graph, Digraph, Bigraph, Matrix)
	(solverMLE, Digraph, Bigraph, Graph, Matrix)
	(solverMLE, Bigraph, Graph, Digraph, Matrix)
	(solverMLE, Graph, Bigraph, Digraph, Matrix)
	(solverMLE, Bigraph, Digraph, Graph, Matrix)
	(solverMLE, Digraph, Graph, Bigraph, Matrix)
	(solverMLE, Matrix, MixedGraph)
	(solverMLE, Matrix, Graph)
	(solverMLE, Matrix, Digraph)
	(solverMLE, Matrix, Bigraph)
	(solverMLE, Matrix, Graph, Digraph)
	(solverMLE, Matrix, Digraph,Graph)
	(solverMLE, Matrix, Digraph,Bigraph)
	(solverMLE, Matrix, Bigraph,Digraph)
	(solverMLE, Matrix, Graph, Bigraph)
	(solverMLE, Matrix, Bigraph, Graph)
	(solverMLE, Matrix, Graph, Digraph, Bigraph)
	(solverMLE, Matrix, Digraph, Bigraph, Graph)
	(solverMLE, Matrix, Bigraph, Graph, Digraph)
	(solverMLE, Matrix, Graph, Bigraph, Digraph)
	(solverMLE, Matrix, Bigraph, Digraph, Graph)
	(solverMLE, Matrix, Digraph, Graph, Bigraph)
    Headline
    	Maximum likelihood estimate of a loopless mixed graph 
    Usage
    	solverMLE(G,U)
    Inputs
    	G:Graph
 	  or @ofClass Digraph@, or @ofClass Bigraph@, or @ofClass MixedGraph@ 
	U:Matrix
	  or @ofClass List@ of sample data. 
	  Alternatively, the sample covariance matrix can be given as input by setting @TO sampleData@ false

    Outputs
        : Sequence
	   consisting of (RR,Matrix,ZZ) or (RR,List,ZZ)
           where the real number is the maximum value attained in the log-likelihood function,
	   the matrix (or list of matrices) is the MLE for the concentration matrix
	   and the integer is the ML-degree of the model   
    Description
    	Text
	    This function takes as input a @TO Graph@, or a @TO Digraph@, or a @TO Bigraph@ or a @TO MixedGraph@ and a list or matrix that encodes, by default, the sample data.
	    It computes the critical points of the score equations and 
	    selects the maximum value achieved among those that lie in the cone of positive-definite matrices.
	    The default output is the maximum value in the log-likelihood function, maximum likelihood estimators (MLE) for the concentration matrix
	    and the ML-degree of the model.
	    MLE for the covariance matrix can be obtained by setting the optional input @TO concentrationMatrix@ to false.
	    
	    The same optional inputs as in @TO scoreEquations@ can be used, plus extra optional inputs related to
	    the numerical solver (EigenSolver by default, NAG4M2 alternatively) and its functionalities.
	    
	    Below we compute Example 2.1.13 for an undirected graph in the book: Mathias Drton, Bernd Sturmfels and Seth Sullivant:
	    {\em Lectures on Algebraic Statistics}, Oberwolfach Seminars, Vol 40, Birkhauser, Basel, 2009.
	    The input is a @TO graph@ and a data sample given as a list:    
	   
	Example
	    G=graph{{1,2},{2,3},{3,4},{1,4}}
	    U = {{1,2,1,-1},{2,1,3,0},{-1, 0, 1, 1},{-5, 3, 4, -6}}
	    solverMLE(G,U)
        Text
	    In the following example we compute the MLE for a @TO mixedGraph@ with
	    directed and bidirected edges. In this case we give as input the sample covariance matrix:
	Example
	    G = mixedGraph(digraph {{1,3},{2,4}},bigraph {{3,4}})
            S =  matrix {{7/20, 13/50, -3/50, -19/100}, {13/50, 73/100, -7/100, -9/100},{-3/50, -7/100, 2/5, 3/50}, {-19/100, -9/100, 3/50, 59/100}}
            solverMLE(G,S,sampleData=>false)

	Text
	   Finally, we provide the MLE of a @TO mixedGraph@ with undirected, directed and bidirected edges:
	Example
	   G = mixedGraph(digraph {{1,3},{2,4}},bigraph {{3,4}},graph {{1,2}})
           S =  matrix {{7/20, 13/50, -3/50, -19/100}, {13/50, 73/100, -7/100, -9/100},{-3/50, -7/100, 2/5, 3/50}, {-19/100, -9/100, 3/50, 59/100}}
           sol = solverMLE(G,S,sampleData=>false,concentrationMatrix=>false) 
    SeeAlso				
       checkPD 
       checkPSD
       scoreEquations
       jacobianMatrixOfRationalFunction
       sampleCovarianceMatrix
///

--******************************************--
-- TESTS     	       	    	      	    --
--******************************************--

TEST /// 
R=QQ[x,y];
FR=frac R;
F=1/(x^2+y^2);
M=entries jacobianMatrixOfRationalFunction(F);
N=transpose {{-2*x/(x^2 + y^2)^2,-2*y/(x^2 + y^2)^2 }};
assert(M === N)
///

TEST ///
R=QQ[x_1,x_2,x_3];
FR=frac R;
M=entries jacobianMatrixOfRationalFunction( (x_1^2*x_2)/(x_1+x_2^2+x_3^3) );
N=transpose {{2*x_1*x_2/(x_2^2 + x_3^3 + x_1) - x_1^2*x_2/(x_2^2 + x_3^3 + x_1)^2, -2*x_1^2*x_2^2/(x_2^2 + x_3^3 + x_1)^2 + x_1^2/(x_2^2 + x_3^3 + x_1) , -3*x_1^2*x_2*x_3^2/(x_2^2 + x_3^3 + x_1)^2 }};
assert(M === N)
/// 

TEST ///
M = {matrix{{1, 2, 0}}, matrix{{-1, 0, 5/1}}, matrix{{3, 5, 2/1}}, matrix{{-1, -4, 1/1}}};
N = sampleCovarianceMatrix(M);
A = matrix {{11/4, 39/8, -1}, {39/8, 171/16, 0}, {-1, 0, 7/2}};
assert(N===A)	
///

TEST ///
X = {matrix {{36, -3, -25, -36}}, matrix {{-10, 11, -29, -20}}, matrix {{-18, 33, -15, -11}}, matrix {{-42, 0, 20, 43}}, matrix {{-30, -26, 32, 2}}, matrix {{2, -38, -24, -43}} };
Y = sampleCovarianceMatrix(X);
B = matrix {{5621/9, -1037/18, -7835/18, -10565/18}, {-1037/18, 19505/36, -4897/36, 5147/36}, {-7835/18, -4897/36, 20465/36, 18941/36}, {-10565/18, 5147/36, 18941/36, 28889/36}};
assert(Y===B)	
///

TEST ///
X = matrix{{48,89,27,28},{23,19,29,94},{135,23,44,71},{91,75,24,98}};
Y = sampleCovarianceMatrix(X);
B = matrix {{29147/16, -1313/8, 220, 1609/16}, {-1313/8, 3827/4, -155, -3451/8}, {220, -155, 119/2, -63/4}, {1609/16, -3451/8, -63/4, 12379/16}};
assert(Y===B)	
///

TEST ///
G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph {{3,4}})
R=gaussianRing(G)
U = {matrix{{1,2,1,-1}}, matrix{{2,1,3,0}}, matrix{{-1, 0, 1, 1}}, matrix{{-5, 3, 4, -6}}}
J=scoreEquations(R,U);
I=ideal(20*p_(3,4)+39,50*p_(4,4)-271,440104*p_(3,3)-742363,230*p_(2,2)-203,16*p_(1,1)-115,5*l_(3,4)+2,110026*l_(2,3)-2575,55013*l_(1,3)-600,115*l_(1,2)+26);
assert(J===I)
///     

TEST ///
G=graph{{1,2},{2,3},{3,4},{1,4}}
R=gaussianRing(G)
U=random(ZZ^4,ZZ^4)
J=scoreEquations(R,U)
assert(dim J===0)
assert(degree J===5)
///   

TEST ///
L={matrix{{1,0},{0,1}},matrix{{-2,0},{0,1}},matrix{{sqrt(-1),0},{0,sqrt (-1)}},matrix{{0.0001*sqrt(-1),0},{0,0.0000001*sqrt (-1)}}};
Y = checkPD(L);
B = {matrix{{1, 0}, {0, 1}}};
assert(Y===B)	
///

TEST ///
L={matrix{{1,0},{0,1}},matrix{{-2,0},{0,1}},matrix{{sqrt(-1),0},{0,sqrt (-1)}},matrix{{0.0001*sqrt(-1),0},{0,0.0000001*sqrt (-1)}},matrix{{0,0},{0,0}}};
Y = checkPSD(L);
B = {matrix{{1, 0}, {0, 1}},matrix{{0,0},{0,0}}};
assert(Y===B)	
///

TEST /// --score equations of sample data equals score equations of its sample covariance data with sampleData=>false    
G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph{{3,4}})
R = gaussianRing(G)
U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,1, 8/3}}
JU=scoreEquations(R,U)
RU=ring(JU)
V = sampleCovarianceMatrix U
JV=scoreEquations(R,V,sampleData=>false)
JV=sub(JV,RU)
assert(JU==JV)
///

TEST /// --score equations with elimination strategy equals default saturation strategy   
G = mixedGraph(digraph {{1,2},{1,3},{2,3},{3,4}},bigraph{{3,4}})
R = gaussianRing(G)
U = matrix{{6, 10, 1/3, 1}, {3/5, 3, 1/2, 1}, {4/5, 3/2, 9/8, 3/10}, {10/7, 2/3,1, 8/3}}
JU=scoreEquations(R,U)
RU=ring(JU)
J=scoreEquations(R,U,saturateOptions => {Strategy => Eliminate})
J=sub(J,RU)
assert(J==JU)
///    
--------------------------------------
--------------------------------------
end--
--------------------------------------
--------------------------------------


--blank documentation node:
doc /// 
    Key
       gaussianMatrix
       (gaussianMatrix,Digraph,Matrix,List) 
    Headline
    Usage
    Inputs
    Outputs
    Description 
        Text
        Example
    SeeAlso
///

restart
uninstallPackage "GraphicalModelsMLE"
restart
--installPackage("Graphs", UserMode=>true)
installPackage ("GraphicalModelsMLE", RemakeAllDocumentation => true, UserMode=>true)
installPackage("GraphicalModelsMLE",UserMode=>true,DebuggingMode => true)
installPackage("GraphicalModelsMLE",UserMode=>true,DebuggingMode => true, FileName =>"/Users/lgp/Software/Macaulay2/Workshop-2020-Warwick/AlgebraicStatistics/GraphicalModelsMLE.m2")
check GraphicalModelsMLE

viewHelp "GraphicalModelsMLE"
help GraphicalModelsMLE

----------------------
-- Parameterization -- ????????????????????????????????????????????????????????????????????????
---------------------- 
---- We need this for both directed and undirected graphs:

----  parameterizations and for toric varieties the corresponding matrix. 
----  In the case of toric varieties the matrix is easy.  Here is the code, 
----  commented out to be used later when we are ready. 
---- 
----  toAMatrix = method()
----  toAMatrix List := Matrix => (M) -> (
----      if any(M,isMonomial)
----         then error "this parameterization does not correspond to a toric ideal." 
----         else (
----              Mexp := apply(M, exponents);
----              transpose matrix apply(Mexp, flatten)))
----
---- isMonomial = method()
---- isMonomial RingElement := Boolean => (m) -> (
----      termList := terms m;
----      if #termList == 1 then true else false)

---- isMonomial works well as long as m is actually a polynomial or monomial and not 
---- an element of ZZ, QQ, RR, etc.


end;
restart
installPackage("GraphicalModelsMLE")
check "GraphicalModelsMLE"


