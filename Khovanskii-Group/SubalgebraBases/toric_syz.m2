export {
    "intrinsicReduce",
    "intrinsicBuchberger",
    "toricSyz",
    "subalgEquals",
    "genVars",
    "isSubalg",
    "autoreduce",
    "toMonomial",
    "extractEntries",
    "debugPrintMap",
    "debugPrintAllMaps",
    "extrinsicBuchberger"
    }

debugPrintMap = method()
debugPrintMap(RingMap) := f -> (
    a := gens source f;
    for i from 0 to (length a)-1 do(
	elt := f(a_i);
	print("maps "|toString(a_i)|" to "|toString(elt));
	);    
    );

debugPrintAllMaps = method()
debugPrintAllMaps(Subring) := subR -> (
    pres := makePresRing(subR);
    print("--------------------------------");
    print("-- PresRing map info dump:");
    print("--------------------------------");
    print("-- ProjectionInclusion:");
    debugPrintMap (pres#"ProjectionInclusion");
    print("-- ProjectionBase:");
    debugPrintMap (pres#"ProjectionBase");
    print("-- InclusionBase:");
    debugPrintMap (pres#"InclusionBase");
    print("-- Substitution:");
    debugPrintMap (pres#"Substitution");
    print("-- FullSub:");
    debugPrintMap (pres#"FullSub");
    print("--------------------------------");
    print("-- End PresRing map info dump.");
    print("--------------------------------");
    );


-- Returns the variables corresponding to the subalgebra generators in the 
-- tensor ring of a subring instance,
    -- subR is any Subring instance.
genVars = method(TypicalValue => Matrix)
genVars(Subring) := subR ->(
    selectInSubring(1, vars subR#"PresRing"#"TensorRing")    
    );

-- Not sure if this function is practically useful or not. For now, it's worth
-- keeping for testing the monomial order on the tensor ring created by the
-- subring constructor.
-- Computes the lead term with respect to the ordering on the upper variables
-- induced from the ordering on the variables of the ambient ring.
   -- subR is any Subring instance.
   -- f is an element of subR's tensor ring.
leadTerm(Subring, RingElement) := (subR, f) -> (
    fullSub := subR#"PresRing"#"FullSub";
    monos := monomials f;
    polys := fullSub monos;
    maxMono := max first entries polys;
    maxIndex := position(first entries polys, p -> p == maxMono);
    leadMono := monos_(0, maxIndex);
    coefficient(leadMono, f)*leadMono
    );
leadTerm(Subring, List) := (subR, L) -> (
    for i from 0 to (length L)-1 list(
	if L#i == 0 then (
	    0
	    ) else(
	    leadTerm(subR, L#i)
	    )
	)
    );

-- This is a bit different than the implementation of leadTerm(Matrix).
-- leadTerm(Matrix) only operates on the first nonzero entry of every column and sets
-- the entries below to zero. This operates on every single entry.  
leadTerm(Subring, Matrix) := (subR, M) -> (
    matrix (apply(entries M, row -> leadTerm(subR, row)))
    );

isSubalg = method(TypicalValue => Boolean)
isSubalg(Subring, Subring) := (A, B) -> (
    (gens A)%B == 0
    );
subalgEquals = method(TypicalValue => Boolean)
subalgEquals(Subring, Subring) := (A, B) ->(
    isSubalg(A, B) and isSubalg(B, A)
    );
Subring == Subring := (A, B) -> (subalgEquals(A,B));

-- converts exponent vector L to a monomial in vars R.
toMonomial = (R, L) ->(
    variableList := flatten entries vars R;
    m := 1;
    for i from 0 to (length L)-1 do(
	m = m*(variableList_i)^(L#i);
	);
    m	  
    );

-- returns the coefficient of the lead monomial of RingElement f.
leadCoef = f ->(
    coefficient(leadMonomial f, f)
    );

debugBreakFlag := false;

-- This is subroutine 11.14 of Sturmfels.
-- There are many simillarities between this calculation and the subduction algorithm.
   -- subR is a subring that contains the ideal generated by the 1-row matrix G.
   -- p is an element of subR#"PresRing"#"TensorRing".
intrinsicReduce = method(TypicalValue => RingElement)
intrinsicReduce(Subring, Matrix, RingElement) := (subR, G, p) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";

    if subR#"isSagbi" == false then(
	error "Can only use IntrinsicReduce on a Subring instance that is a Sagbi basis.";
	);
    
    -- This is one way to guarentee that p is actually an element of subR,
    -- but it requires p to be put into normal form beforehand which is an
    -- expensive operation. 
    -- TODO: Look into what happens when p isn't an element of subR.
    --if projInc p != p then(
	--error "p must be a polynomial in the generators of subR."
	--);
    --if projInc G != G then(
        --error "G must contain entries that are polynomials in the generators of subR."
        --);
    
    amb := ambient subR;
    fullSub := pres#"FullSub";
    result := p;
    
    -- If the  === comparison is true, it  does not guarentee that will not throw an error.
    if source fullSub === ring p then(
    	result = fullSub p;
    	);    
    if source fullSub === ring G then(
    	G = fullSub G;
    	);
   
    -- This call to sagbi will not take long.
    KA := sagbi subring(leadTerm gens subR);
    tenseKA := KA#"PresRing"#"TensorRing";
    Q := (leadTerm G)//KA;
    
    -- This is an ideal inside of the _tensor ring_ of KA.
    I := monomialIdeal(Q);

    loopNum := 0;    	
    while true do (
	if loopNum % 100 == 0 and loopNum > 0 then(
	    print("reduction step:"|toString(loopNum));
	    );	
	badTerms := result // KA;
	badTerms = badTerms-(badTerms%I);
	badTerms = selectInSubring(1, monomials badTerms);		
	
       	if badTerms == 0 then(
	    break;
	    );
	fullSubKA := KA#"PresRing"#"FullSub";
	subMap := KA#"PresRing"#"Substitution";

	tb := fullSubKA max first entries badTerms;	
	assert(coefficient(tb, result) != 0);
	
	pos := position(first entries Q, gen -> (tb//KA)%(monomialIdeal gen) == 0);
	assert(pos =!= null);
	
	g := fullSubKA (Q_(0,pos));
	v := first ((exponents tb)-(exponents g));
	
	-- mono is supposed to be an element of subR.
	mono := toMonomial(amb,v)//subR;
	mono = fullSub(mono);
	assert(mono%subR == 0);

	-- g is supposed to an element of the subring generated by G.
	g = G_(0,pos);	
	
	-- since an ideal absorbs outside products, we know that diffPoly is an element of ideal G.
	diffPoly := g*mono;
		
	if(diffPoly == 0) then(
	    error "This is not supposed to happen. (Possibly a bug within the function intrinsicReduce.)";
	    );
	
	coef := coefficient(tb, diffPoly);
	assert( (leadTerm diffPoly) == tb*coef);
	assert(coefficient(tb, result) != 0);
	diffPoly = diffPoly * (1/coefficient(tb, diffPoly));
	diffPoly = diffPoly * coefficient(tb, result);
        assert(coefficient(tb, diffPoly) == coefficient(tb, result));
	result = result - diffPoly;	
		
	loopNum = loopNum + 1;
    	);
    assert(result%subR == 0);  
    result
    );

-- applies intrinsicReduce to each entry of the 1-row matrix M.
intrinsicReduce(Subring, Matrix, Matrix) := (subR, G, M) -> (
    matrix({apply(first entries M, ent -> intrinsicReduce(subR, G, ent))})
    );

-- algorithm 11.24
extrinsicBuchberger = method(TypicalValue => Matrix)
extrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    G := (gens gb (transpose (S//subR)));
    G = subR#"PresRing"#"FullSub"(G);
    G = transpose compress G;
    mingensSubring(subR, G)
    );

-- This is subroutine 11.17 of Sturmfels.
-- NOTE: intrinsicBuchberger calls both intrinsicReduce and toricSyz. If intrinsicBuchberger is
-- tested extensively, toricSyz and intrinsicReduce can be safely assumed to be correct.
   -- subR is a subring that contains the ideal generated by the 1-row matrix S.
   -- S is a 1-row matrix with entries in the upper variables of subR's TensorRing.
intrinsicBuchberger = method(TypicalValue => Matrix)
intrinsicBuchberger(Subring, Matrix) := (subR, S) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    amb := ambient subR;
    
    if subR#"isSagbi" == false then(
	error "Can only use intrinsicBuchberger on a Subring instance that is a Sagbi basis.";
	);
    if projInc S != S then(
	error "G must contain entries that are polynomials in the generators of subR."
	);
    
    encountered := set(first entries S);
    currentGens := S;
    
    KA := sagbi subring leadTerm gens subR;

    loopNum := 0;
    while true do(
	print("---------------------------------");
	print("-- loop number "|toString(loopNum)|":");
	
    	C := leadTerm(fullSub currentGens);
	print("finding toric syzygies...");
	M := toricSyz(subR, C);
	print("num. syzygies before autoreduction:"|toString(numrows M));	
	print("computing autoreduction...");
	if(loopNum == 1) then(
	    debugBreakFlag = true;
	    --error "break";
	    );
	
	
	--M = mingensSubring(KA, M);
	M = transpose compress KA#"PresRing"#"FullSub"(gens gb (transpose M//KA));	
	
	print("num. syzygies after reduction: "|toString(numrows M));	
    	newGens := for i from 0 to (numrows M) - 1 list(
	    H := (M^{i} // subR);
	    
	    -- These assertions are condition 4.1.
	    A := M^{i};
	    B := leadTerm fullSub H;
	    assert( H % subR == 0); -- H is an element of SubR^r.
	    assert( A - B == 0);

    	    f := sum(for j from 0 to (numcols currentGens)-1 list(H_(0,j)*(currentGens_(0,j)))); 
	    
	    --assert(f%subR == 0); 
	    hbar := intrinsicReduce(subR, S, f);
	    --assert(hbar%subR == 0);
	    
	    if hbar == 0 then(
		print("zero");
	    	continue;
		);
	    hbar = hbar * (1/(leadCoef hbar));
	    if member(hbar, encountered) then(
		print("not new...");
		);
	    print("New - (#terms:"|toString(numcols monomials hbar)|" degree:"|toString(degree hbar)|")");
	    encountered = encountered + set({hbar});
	    hbar
	    );
	print("-- total new generators:"|toString(length newGens));
			
    	if newGens == {} then (
	    print("-- No new gens found.");
    	    break;	
	    )else(
	    newGens = subR#"PresRing"#"InclusionBase"(matrix({newGens}));
	    currentGens = currentGens | newGens;
	    );
    	loopNum = loopNum + 1;
        );
    print("-- Computing normal form of generators...");    
    currentGens = currentGens // subR;        
    print("-- Computing autoreduction...");
    error "stop";
    autoreduce(subR, currentGens)
    );

-- Perform autoreduction on the generators of an intrinsic ideal:
-- I.e., reduce g\in idealGens modulo idealGens-g for all g\in idealGens.   
   -- subR is a Subring (probably has to be a Sagbi basis)
   -- idealGens is a matrix containing generators of an ideal in subR.
autoreduce = method(TypicalValue => Matrix)
autoreduce(Subring, Matrix) := (subR, idealGens) -> (
    noDupes := new MutableList from first entries idealGens;        
    reducedGens := for i from 0 to (numcols idealGens)-1 list(		
	s := idealGens_(0,i);
	notS := submatrix'(matrix({toList noDupes}),,{i});      
	print("----------- autoreduction step "|toString(i)|"/"|toString(numcols idealGens)|"  --------------");
	answer := intrinsicReduce(subR, notS, s);
       	answer = sub(answer,ring idealGens);
	noDupes#i = answer;	
	answer
	);
    -- The extra "matrix entries" is to eliminate the degrees (which are the numbers in curly brackets)
    -- I don't know what they are for and they break the == operator.
    matrix entries (transpose compress (matrix({reducedGens})))
    );

-- This is subroutine 11.18 of Sturmfels.
-- Assumes M is a matrix of monomials in the toric ring K[A]
-- (for now,  it can be anything in the tensor ring of subR satisfying this condition,
-- involving the generators or the variables.)
toricSyz = method(TypicalValue => Matrix)
toricSyz(Subring, Matrix) := (subR, M) -> (
    
    pres := subR#"PresRing";
    tense := pres#"TensorRing";
    projInc := pres#"ProjectionInclusion";
    fullSub := pres#"FullSub";
    subMap := pres#"Substitution";
    incBase := pres#"InclusionBase";
    
    amb := ambient subR;
    r := numcols M;
    
    if subR#"isSagbi" == false then(
	error "Can only use toricSyz on a Subring instance that is a Sagbi basis.";
	);
    if ring M === amb then(
	M = (pres#"InclusionBase")(M);
	) else if ring M =!= tense then(
	error "The entries of M must be in either the TensorRing or ambient ring of A.";
	);
    KA := subring leadTerm gens subR;
    tenseKA := KA#"PresRing"#"TensorRing";
    M = sub(M, tenseKA);    
    M = (KA#"PresRing"#"Substitution")(M);
    if leadTerm M != M then(
	error "Expected a 1-row matrix of monomials."; 
	); 
    
    U := M // KA;
    -- If some entry of M is not an element of KA, its normal form is zero.
    -- This will cause the assertion to fail.
    assert(KA#"PresRing"#"Substitution"(U) == M);

    -- each column of syzU is a relation of U.
    syzU := syz U;
    special := transpose syzU;
    
    -- U is supposed to in the upper variables only. 
    assert(KA#"PresRing"#"ProjectionInclusion" U == U);
    
    intersection := selectInSubring(1, gens gb intersect(ideal U, KA#"PresRing"#"LiftedPres"));    
    
    binomials := for i from 0 to (numcols intersection)-1 list(
	ent := intersection_(0,i);
	coefs := apply(first entries U, e -> monoCoef(e, ent));
      	if position(coefs, c -> c != 0) === null then (
	    error "Error: something impossible happened. (This may be a bug in the function toricSyz.)";
	    );
    	coefs 
	);
    binomials = (matrix binomials) || special;
    fullSubKA := KA#"PresRing"#"FullSub";
    binomials = transpose compress transpose fullSubKA binomials;
    matrix entries binomials
    );
